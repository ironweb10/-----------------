"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable no-restricted-syntax */
const events_1 = require("events");
const collection_1 = (0, tslib_1.__importDefault)(require("@discordjs/collection"));
const Enums_1 = (0, tslib_1.__importDefault)(require("../../enums/Enums"));
const Util_1 = require("../util/Util");
const Auth_1 = (0, tslib_1.__importDefault)(require("./Auth"));
const HTTP_1 = (0, tslib_1.__importDefault)(require("./HTTP"));
const AsyncLock_1 = (0, tslib_1.__importDefault)(require("../util/AsyncLock"));
const Endpoints_1 = (0, tslib_1.__importDefault)(require("../../resources/Endpoints"));
const ClientUser_1 = (0, tslib_1.__importDefault)(require("../structures/ClientUser"));
const XMPP_1 = (0, tslib_1.__importDefault)(require("./XMPP"));
const Friend_1 = (0, tslib_1.__importDefault)(require("../structures/Friend"));
const User_1 = (0, tslib_1.__importDefault)(require("../structures/User"));
const UserNotFoundError_1 = (0, tslib_1.__importDefault)(require("../exceptions/UserNotFoundError"));
const StatsPrivacyError_1 = (0, tslib_1.__importDefault)(require("../exceptions/StatsPrivacyError"));
const CreatorCode_1 = (0, tslib_1.__importDefault)(require("../structures/CreatorCode"));
const CreatorCodeNotFoundError_1 = (0, tslib_1.__importDefault)(require("../exceptions/CreatorCodeNotFoundError"));
const FriendNotFoundError_1 = (0, tslib_1.__importDefault)(require("../exceptions/FriendNotFoundError"));
const DuplicateFriendshipError_1 = (0, tslib_1.__importDefault)(require("../exceptions/DuplicateFriendshipError"));
const FriendshipRequestAlreadySentError_1 = (0, tslib_1.__importDefault)(require("../exceptions/FriendshipRequestAlreadySentError"));
const InviterFriendshipsLimitExceededError_1 = (0, tslib_1.__importDefault)(require("../exceptions/InviterFriendshipsLimitExceededError"));
const InviteeFriendshipsLimitExceededError_1 = (0, tslib_1.__importDefault)(require("../exceptions/InviteeFriendshipsLimitExceededError"));
const InviteeFriendshipRequestLimitExceededError_1 = (0, tslib_1.__importDefault)(require("../exceptions/InviteeFriendshipRequestLimitExceededError"));
const InviteeFriendshipSettingsError_1 = (0, tslib_1.__importDefault)(require("../exceptions/InviteeFriendshipSettingsError"));
const IncomingPendingFriend_1 = (0, tslib_1.__importDefault)(require("../structures/IncomingPendingFriend"));
const OutgoingPendingFriend_1 = (0, tslib_1.__importDefault)(require("../structures/OutgoingPendingFriend"));
const BlockedUser_1 = (0, tslib_1.__importDefault)(require("../structures/BlockedUser"));
const ClientParty_1 = (0, tslib_1.__importDefault)(require("../structures/ClientParty"));
const SendMessageError_1 = (0, tslib_1.__importDefault)(require("../exceptions/SendMessageError"));
const Party_1 = (0, tslib_1.__importDefault)(require("../structures/Party"));
const PartyNotFoundError_1 = (0, tslib_1.__importDefault)(require("../exceptions/PartyNotFoundError"));
const EpicgamesAPIError_1 = (0, tslib_1.__importDefault)(require("../exceptions/EpicgamesAPIError"));
const PartyPermissionError_1 = (0, tslib_1.__importDefault)(require("../exceptions/PartyPermissionError"));
const PartyMaxSizeReachedError_1 = (0, tslib_1.__importDefault)(require("../exceptions/PartyMaxSizeReachedError"));
const Tournament_1 = (0, tslib_1.__importDefault)(require("../structures/Tournament"));
const SentPartyJoinRequest_1 = (0, tslib_1.__importDefault)(require("../structures/SentPartyJoinRequest"));
const UserSearchResult_1 = (0, tslib_1.__importDefault)(require("../structures/UserSearchResult"));
const RadioStation_1 = (0, tslib_1.__importDefault)(require("../structures/RadioStation"));
const SentFriendMessage_1 = (0, tslib_1.__importDefault)(require("../structures/SentFriendMessage"));
const MatchNotFoundError_1 = (0, tslib_1.__importDefault)(require("../exceptions/MatchNotFoundError"));
const CreativeIslandNotFoundError_1 = (0, tslib_1.__importDefault)(require("../exceptions/CreativeIslandNotFoundError"));
const Avatar_1 = (0, tslib_1.__importDefault)(require("../structures/Avatar"));
const GlobalProfile_1 = (0, tslib_1.__importDefault)(require("../structures/GlobalProfile"));
const OfferNotFoundError_1 = (0, tslib_1.__importDefault)(require("../exceptions/OfferNotFoundError"));
/**
 * Represets the main client
 */
class Client extends events_1.EventEmitter {
    /**
     * @param config The client's configuration options
     */
    constructor(config = {}) {
        var _a;
        super();
        this.config = {
            savePartyMemberMeta: true,
            http: {},
            debug: undefined,
            httpDebug: undefined,
            xmppDebug: undefined,
            defaultStatus: undefined,
            defaultOnlineType: 'online',
            platform: 'WIN',
            defaultPartyMemberMeta: {},
            xmppKeepAliveInterval: 30,
            createParty: true,
            forceNewParty: true,
            connectToXMPP: true,
            fetchFriends: true,
            restRetryLimit: 1,
            handleRatelimits: true,
            partyBuildId: '1:3:',
            restartOnInvalidRefresh: false,
            ...config,
            cacheSettings: {
                ...config.cacheSettings,
                presences: {
                    maxLifetime: Infinity,
                    sweepInterval: 0,
                    ...(_a = config.cacheSettings) === null || _a === void 0 ? void 0 : _a.presences,
                },
            },
            auth: {
                authorizationCode: async () => (0, Util_1.consoleQuestion)('Please enter an authorization code: '),
                checkEULA: true,
                killOtherTokens: true,
                authClient: 'fortniteIOSGameClient',
                ...config.auth,
            },
            partyConfig: {
                privacy: Enums_1.default.PartyPrivacy.PUBLIC,
                joinConfirmation: false,
                joinability: 'OPEN',
                maxSize: 16,
                chatEnabled: true,
                discoverability: 'ALL',
                ...config.partyConfig,
            },
        };
        this.timeouts = new Set();
        this.intervals = new Set();
        this.auth = new Auth_1.default(this);
        this.http = new HTTP_1.default(this);
        this.xmpp = new XMPP_1.default(this);
        this.reauthLock = new AsyncLock_1.default();
        this.partyLock = new AsyncLock_1.default();
        this.user = undefined;
        this.isReady = false;
        this.friends = new collection_1.default();
        this.pendingFriends = new collection_1.default();
        this.blockedUsers = new collection_1.default();
        this.party = undefined;
        this.lastPartyMemberMeta = this.config.defaultPartyMemberMeta;
    }
    // Events
    on(event, listener) {
        return super.on(event, listener);
    }
    once(event, listener) {
        return super.once(event, listener);
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    /* -------------------------------------------------------------------------- */
    /*                           CLIENT LOGIN AND LOGOUT                          */
    /* -------------------------------------------------------------------------- */
    /**
     * Logs the client in.
     * A valid authentication method must be provided in the client's config.
     * By default, there will be a console prompt asking for an authorization code
     * @throws {EpicgamesAPIError}
     * @throws {EpicgamesGraphQLError}
     */
    async login() {
        const auth = await this.auth.authenticate();
        if (!auth.response)
            throw auth.error || new Error('Couldn\'t authenticate the client');
        const clientInfo = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_ID}/${auth.response.account_id}`, 'fortnite');
        if (!clientInfo.response)
            throw clientInfo.error || new Error('Couldn\'t fetch the client\'s account info');
        this.user = new ClientUser_1.default(this, clientInfo.response);
        await this.user.fetch();
        this.initCacheSweeping();
        if (this.config.connectToXMPP) {
            this.xmpp.setup();
            const xmpp = await this.xmpp.connect();
            if (!xmpp.response)
                throw xmpp.error || new Error('Couldn\'t connect to XMPP');
        }
        if (this.config.fetchFriends) {
            await this.updateCaches();
        }
        await this.initParty(this.config.createParty, this.config.forceNewParty);
        this.setStatus();
        this.isReady = true;
        this.emit('ready');
    }
    /**
     * Logs the client out.
     * Also clears all caches, etc
     */
    async logout() {
        await this.auth.killAllTokens();
        await this.xmpp.disconnect();
        this.destroy();
        this.isReady = false;
        this.emit('disconnected');
    }
    /**
     * Restarts the client
     */
    async restart() {
        var _a;
        const refreshToken = (_a = this.auth.auths.get('fortnite')) === null || _a === void 0 ? void 0 : _a.refresh_token;
        await this.logout();
        this.config.auth.refreshToken = refreshToken;
        await this.login();
    }
    /**
     * Initializes {@link Client#party}
     * @param createNew Whether to create a new party
     * @param forceNew Whether to force create a new party
     */
    async initParty(createNew = true, forceNew = true) {
        this.party = await this.getClientParty();
        if (!forceNew && this.party)
            return;
        if (createNew) {
            await this.leaveParty(false);
            await this.createParty();
        }
    }
    /**
     * Waits until the client is ready
     * @param timeout How long to wait for until an error is thrown
     */
    async waitUntilReady(timeout = 10000) {
        if (this.isReady)
            return;
        this.setMaxListeners(this.getMaxListeners() + 1);
        try {
            await this.waitForEvent('ready', timeout);
        }
        finally {
            this.setMaxListeners(this.getMaxListeners() - 1);
        }
    }
    /**
     * Cleanup method
     */
    destroy() {
        // Clear timeouts
        for (const interval of this.intervals)
            clearInterval(interval);
        for (const timeout of this.timeouts)
            clearTimeout(timeout);
        this.timeouts.clear();
        this.intervals.clear();
        // Clear remaining caches
        this.friends.clear();
        this.pendingFriends.clear();
        this.blockedUsers.clear();
    }
    /**
     * Initializes the sweeping of cached objects
     */
    initCacheSweeping() {
        const { cacheSettings } = this.config;
        const presenceCacheSettings = cacheSettings.presences;
        if (presenceCacheSettings && presenceCacheSettings.sweepInterval && presenceCacheSettings.sweepInterval > 0
            && presenceCacheSettings.maxLifetime > 0 && presenceCacheSettings.maxLifetime !== Infinity) {
            this.setInterval(this.sweepPresences.bind(this), presenceCacheSettings.sweepInterval);
        }
    }
    /**
     * Updates the client's caches
     */
    async updateCaches() {
        var _a;
        const friendsSummary = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.FRIENDS}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/summary`, 'fortnite');
        if (friendsSummary.error)
            throw friendsSummary.error;
        this.friends.clear();
        this.pendingFriends.clear();
        this.blockedUsers.clear();
        friendsSummary.response.friends.forEach((f) => {
            this.friends.set(f.accountId, new Friend_1.default(this, { ...f, id: f.accountId }));
        });
        friendsSummary.response.incoming.forEach((f) => {
            this.pendingFriends.set(f.accountId, new IncomingPendingFriend_1.default(this, { ...f, id: f.accountId }));
        });
        friendsSummary.response.outgoing.forEach((f) => {
            this.pendingFriends.set(f.accountId, new OutgoingPendingFriend_1.default(this, { ...f, id: f.accountId }));
        });
        friendsSummary.response.blocklist.forEach((u) => {
            this.blockedUsers.set(u.accountId, new BlockedUser_1.default(this, { ...u, id: u.accountId }));
        });
        const users = await this.getProfile([...this.friends.values(), ...this.pendingFriends.values(), ...this.blockedUsers.values()]
            .filter((u) => !!u.id).map((u) => u.id));
        users.forEach((u) => {
            var _a, _b, _c;
            (_a = this.friends.get(u.id)) === null || _a === void 0 ? void 0 : _a.update(u);
            (_b = this.pendingFriends.get(u.id)) === null || _b === void 0 ? void 0 : _b.update(u);
            (_c = this.blockedUsers.get(u.id)) === null || _c === void 0 ? void 0 : _c.update(u);
        });
    }
    /**
     * Removes presences from the clients cache that are older than the max lifetime
     * @param maxLifetime How old a presence must be before it can be sweeped (in ms)
     * @returns The amount of presences sweeped
     */
    sweepPresences(maxLifetime) {
        var _a, _b;
        if (maxLifetime === void 0) { maxLifetime = (_a = this.config.cacheSettings.presences) === null || _a === void 0 ? void 0 : _a.maxLifetime; }
        if (typeof maxLifetime !== 'number')
            throw new TypeError('maxLifetime must be typeof number');
        let presences = 0;
        for (const friend of this.friends.values()) {
            if (typeof ((_b = friend.presence) === null || _b === void 0 ? void 0 : _b.receivedAt) !== 'undefined' && Date.now() - friend.presence.receivedAt.getTime() > maxLifetime) {
                delete friend.presence;
                presences += 1;
            }
        }
        return presences;
    }
    /* -------------------------------------------------------------------------- */
    /*                                    UTIL                                    */
    /* -------------------------------------------------------------------------- */
    /**
     * Wait until an event is emitted
     * @param event The event that will be waited for
     * @param timeout The timeout (in milliseconds)
     * @param filter The filter for the event
     */
    waitForEvent(event, timeout = 5000, 
    // eslint-disable-next-line no-unused-vars
    filter) {
        return new Promise((res, rej) => {
            const handler = (...data) => {
                if (!filter || filter(...data)) {
                    this.removeListener(event, handler);
                    res(data);
                }
            };
            this.on(event, handler);
            setTimeout(() => {
                this.removeListener(event, handler);
                rej(new Error('Event timeout exceed'));
            }, timeout);
        });
    }
    /**
     * Sets a timeout that will be automatically cancelled if the client is logged out
     * @param fn Function to execute
     * @param delay Time to wait before executing (in milliseconds)
     * @param args Arguments for the function
     */
    // eslint-disable-next-line no-unused-vars
    setTimeout(fn, delay, ...args) {
        const timeout = setTimeout(() => {
            fn(args);
            this.timeouts.delete(timeout);
        }, delay);
        this.timeouts.add(timeout);
        return timeout;
    }
    /**
     * Clears a timeout
     * @param timeout Timeout to cancel
     */
    // eslint-disable-next-line no-undef
    clearTimeout(timeout) {
        clearTimeout(timeout);
        this.timeouts.delete(timeout);
    }
    /**
     * Sets an interval that will be automatically cancelled if the client is logged out
     * @param fn Function to execute
     * @param delay Time to wait between executions (in milliseconds)
     * @param args Arguments for the function
     */
    // eslint-disable-next-line no-unused-vars
    setInterval(fn, delay, ...args) {
        const interval = setInterval(fn, delay, ...args);
        this.intervals.add(interval);
        return interval;
    }
    /**
     * Clears an interval.
     * @param interval Interval to cancel
     */
    // eslint-disable-next-line no-undef
    clearInterval(interval) {
        clearInterval(interval);
        this.intervals.delete(interval);
    }
    static consoleQuestion(question) {
        return (0, Util_1.consoleQuestion)(question);
    }
    /**
     * Debug a message using the methods set in the client config
     * @param message Text to debug
     * @param type Debug type (regular, http or xmpp)
     */
    debug(message, type = 'regular') {
        switch (type) {
            case 'regular':
                if (typeof this.config.debug === 'function')
                    this.config.debug(message);
                break;
            case 'http':
                if (typeof this.config.httpDebug === 'function')
                    this.config.httpDebug(message);
                break;
            case 'xmpp':
                if (typeof this.config.xmppDebug === 'function')
                    this.config.xmppDebug(message);
                break;
        }
    }
    /**
     * Fetches one or multiple Epicgames accounts by id or display name
     * Returns undefined if the user(s) wasn't/weren't found
     * @param query An array of display names and/or account ids
     * @throws {EpicgamesAPIError}
     */
    async getProfile(query) {
        if (typeof query === 'string') {
            let user;
            if (query.length === 32) {
                user = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_MULTIPLE}?accountId=${query}`, 'fortnite');
            }
            else if (query.length >= 3 && query.length <= 16) {
                user = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_DISPLAYNAME}/${encodeURIComponent(query)}`, 'fortnite');
            }
            else
                return undefined;
            if (user === null || user === void 0 ? void 0 : user.error) {
                if (user.error.code === 'errors.com.epicgames.account.account_not_found')
                    return undefined;
                throw user.error;
            }
            if (Array.isArray(user.response) && !user.response[0])
                return undefined;
            return new User_1.default(this, Array.isArray(user === null || user === void 0 ? void 0 : user.response) ? user === null || user === void 0 ? void 0 : user.response[0] : user === null || user === void 0 ? void 0 : user.response);
        }
        const displayNames = [];
        const ids = [];
        query.forEach((q) => {
            if (q.length === 32)
                ids.push(q);
            else if (q.length >= 3 && q.length <= 16)
                displayNames.push(q);
        });
        const proms = [];
        proms.push(...displayNames
            .map((dn) => this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_DISPLAYNAME}/${encodeURIComponent(dn)}`, 'fortnite')));
        const idChunks = ids.reduce((resArr, id, i) => {
            const chunkIndex = Math.floor(i / 100);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(id);
            return resArr;
        }, []);
        proms.push(...idChunks
            .map((ic) => this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_MULTIPLE}?accountId=${ic.join('&accountId=')}`, 'fortnite')));
        const users = await Promise.all(proms);
        return users.map((u) => {
            if (u === null || u === void 0 ? void 0 : u.error) {
                if (u.error.code === 'errors.com.epicgames.account.account_not_found')
                    return undefined;
                throw u.error;
            }
            if (Array.isArray(u.response))
                return u.response.map((ur) => new User_1.default(this, ur));
            return new User_1.default(this, u.response);
        }).filter((u) => !!u).flat(1);
    }
    /**
     * Fetches users that match a prefix
     * @param prefix The prefix (a string that the user's display names start with)
     * @param platform The search platform. Other platform's accounts will still be searched with a lower priority
     */
    async searchProfiles(prefix, platform = 'epic') {
        var _a;
        const results = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_SEARCH}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}?prefix=${encodeURIComponent(prefix)}&platform=${platform}`, 'fortnite');
        const users = await this.getProfile(results.response.map((r) => r.accountId));
        return results.response.map((r) => new UserSearchResult_1.default(this, users.find((u) => u.id === r.accountId), r));
    }
    /**
     * Resolves a single user id
     * @param query Display name or id of the account's id to resolve
     */
    async resolveUserId(query) {
        var _a;
        if (query.length === 32)
            return query;
        return (_a = (await this.getProfile(query))) === null || _a === void 0 ? void 0 : _a.id;
    }
    /**
     * Resolves multiple user ids
     * @param query Display names or ids of the account's ids to resolve
     */
    async resolveUserIds(query) {
        const displayNames = [];
        const ids = [];
        query.forEach((q) => {
            if (q.length === 32)
                ids.push(q);
            else if (q.length >= 3 && q.length <= 16)
                displayNames.push(q);
        });
        const users = await Promise.all(displayNames.map((dn) => this.getProfile(dn)));
        return [...ids.map((id) => ({ id, query: id })), ...users.filter((u) => !!u).map((u) => ({ id: u === null || u === void 0 ? void 0 : u.id, query: u === null || u === void 0 ? void 0 : u.displayName }))];
    }
    /* -------------------------------------------------------------------------- */
    /*                                   FRIENDS                                  */
    /* -------------------------------------------------------------------------- */
    /**
     * Sets the clients XMPP status
     * @param status The status
     * @param onlineType The presence's online type (eg "away")
     * @param friend A specific friend you want to send this status to
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     */
    setStatus(status, onlineType, friend) {
        var _a, _b, _c;
        // eslint-disable-next-line no-undef-init
        let toJID = undefined;
        if (friend) {
            const resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
            if (!resolvedFriend)
                throw new FriendNotFoundError_1.default(friend);
            toJID = `${resolvedFriend.id}@${Endpoints_1.default.EPIC_PROD_ENV}`;
        }
        // eslint-disable-next-line no-undef-init
        let partyJoinInfoData = undefined;
        if (this.party) {
            const partyPrivacy = this.party.config.privacy;
            if (partyPrivacy.presencePermission === 'Noone' || (partyPrivacy.presencePermission === 'Leader' && !((_a = this.party.me) === null || _a === void 0 ? void 0 : _a.isLeader))) {
                partyJoinInfoData = {
                    isPrivate: true,
                };
            }
            else {
                partyJoinInfoData = {
                    sourceId: (_b = this.user) === null || _b === void 0 ? void 0 : _b.id,
                    sourceDisplayName: (_c = this.user) === null || _c === void 0 ? void 0 : _c.displayName,
                    sourcePlatform: this.config.platform,
                    partyId: this.party.id,
                    partyTypeId: 286331153,
                    key: 'k',
                    appId: 'Fortnite',
                    buildId: this.config.partyBuildId,
                    partyFlags: -2024557306,
                    notAcceptingReason: 0,
                    pc: this.party.size,
                };
            }
        }
        if (status)
            this.config.defaultStatus = status;
        if (onlineType)
            this.config.defaultOnlineType = onlineType;
        const rawStatus = {
            Status: this.config.defaultStatus
                || (this.party && `Battle Royale Lobby - ${this.party.size} / ${this.party.maxSize}`) || 'Playing Battle Royale',
            bIsPlaying: false,
            bIsJoinable: false,
            bHasVoiceSupport: false,
            SessionId: '',
            Properties: {
                'party.joininfodata.286331153_j': partyJoinInfoData,
                FortBasicInfo_j: {
                    homeBaseRating: 1,
                },
                FortLFG_I: '0',
                FortPartySize_i: 1,
                FortSubGame_i: 1,
                InUnjoinableMatch_b: false,
                FortGameplayStats_j: {
                    state: '',
                    playlist: 'None',
                    numKills: 0,
                    bFellToDeath: false,
                },
            },
        };
        const rawOnlineType = this.config.defaultOnlineType === 'online' ? undefined : this.config.defaultOnlineType;
        return this.xmpp.sendStatus(rawStatus, rawOnlineType, toJID);
    }
    /**
     * Resets the client's XMPP status and online type
     */
    async resetStatus() {
        this.config.defaultStatus = undefined;
        this.config.defaultOnlineType = 'online';
        return this.setStatus();
    }
    /**
     * Sends a friendship request to a user or accepts an existing request
     * @param friend The id or display name of the user to add
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {DuplicateFriendshipError} The user is already friends with the client
     * @throws {FriendshipRequestAlreadySentError} A friendship request has already been sent to the user
     * @throws {InviterFriendshipsLimitExceededError} The client's friendship limit is reached
     * @throws {InviteeFriendshipsLimitExceededError} The user's friendship limit is reached
     * @throws {InviteeFriendshipSettingsError} The user disabled friend requests
     * @throws {InviteeFriendshipRequestLimitExceededError} The user's incoming friend request limit is reached
     * @throws {EpicgamesAPIError}
     */
    async addFriend(friend) {
        var _a;
        const userID = await this.resolveUserId(friend);
        if (!userID)
            throw new UserNotFoundError_1.default(friend);
        const addFriend = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.FRIEND_ADD}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/${userID}`, 'fortnite');
        if (addFriend.error) {
            switch (addFriend.error.code) {
                case 'errors.com.epicgames.friends.duplicate_friendship':
                    throw new DuplicateFriendshipError_1.default(friend);
                case 'errors.com.epicgames.friends.friend_request_already_sent':
                    throw new FriendshipRequestAlreadySentError_1.default(friend);
                case 'errors.com.epicgames.friends.inviter_friendships_limit_exceeded':
                    throw new InviterFriendshipsLimitExceededError_1.default(friend);
                case 'errors.com.epicgames.friends.invitee_friendships_limit_exceeded':
                    throw new InviteeFriendshipsLimitExceededError_1.default(friend);
                case 'errors.com.epicgames.friends.incoming_friendships_limit_exceeded':
                    throw new InviteeFriendshipRequestLimitExceededError_1.default(friend);
                case 'errors.com.epicgames.friends.cannot_friend_due_to_target_settings':
                    throw new InviteeFriendshipSettingsError_1.default(friend);
                case 'errors.com.epicgames.friends.account_not_found':
                    throw new UserNotFoundError_1.default(friend);
                default:
                    throw addFriend.error;
            }
        }
    }
    /**
     * Removes a friend from the client's friend list or declines / aborts a pending friendship request
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async removeFriend(friend) {
        var _a;
        let resolvedFriend;
        resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            resolvedFriend = this.pendingFriends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const removeFriend = await this.http.sendEpicgamesRequest(true, 'DELETE', `${Endpoints_1.default.FRIEND_DELETE}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/friends/${resolvedFriend.id}`, 'fortnite');
        if (removeFriend.error)
            throw removeFriend.error;
    }
    /**
     * Fetches the friends the client shares with a friend
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async getMutualFriends(friend) {
        var _a;
        const resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const mutualFriends = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.FRIENDS}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/friends/${resolvedFriend.id}/mutual`, 'fortnite');
        if (mutualFriends.error)
            throw mutualFriends.error;
        return mutualFriends.response.map((f) => this.friends.get(f)).filter((f) => !!f);
    }
    /**
     * Checks whether a friend owns a specific offer
     * @param friend The id or display name of the friend
     * @param offerId The offer id
     * @throws {OfferNotFoundError} The offer does not exist or is not in the current storefront catalog
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async checkFriendOfferOwnership(friend, offerId) {
        const resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const giftData = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_GIFT_ELIGIBILITY}/recipient/${resolvedFriend.id}`
            + `/offer/${encodeURIComponent(offerId)}`, 'fortnite');
        if (giftData.error) {
            if (giftData.error.code === 'errors.com.epicgames.modules.gamesubcatalog.catalog_out_of_date')
                throw new OfferNotFoundError_1.default(offerId);
            if (giftData.error.code === 'errors.com.epicgames.modules.gamesubcatalog.purchase_not_allowed')
                return true;
            throw giftData.error;
        }
        return false;
    }
    /**
     * Blocks a user
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async blockUser(user) {
        var _a;
        const userID = await this.resolveUserId(user);
        if (!userID)
            throw new UserNotFoundError_1.default(user);
        const blockUser = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.FRIEND_BLOCK}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/${userID}`, 'fortnite');
        if (blockUser.error)
            throw blockUser.error;
    }
    /**
     * Unblocks a user
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async unblockUser(user) {
        var _a;
        const blockedUser = this.blockedUsers.find((u) => u.displayName === user || u.id === user);
        if (!blockedUser)
            throw new UserNotFoundError_1.default(user);
        const unblockUser = await this.http.sendEpicgamesRequest(true, 'DELETE', `${Endpoints_1.default.FRIEND_BLOCK}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/${blockedUser.id}`, 'fortnite');
        if (unblockUser.error)
            throw unblockUser.error;
    }
    /**
     * Sends a message to a friend
     * @param friend The id or display name of the friend
     * @param content The message that will be sent
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {SendMessageError} The messant could not be sent
     */
    async sendFriendMessage(friend, content) {
        const resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        if (!this.xmpp.isConnected)
            throw new SendMessageError_1.default('You\'re not connected via XMPP', 'FRIEND', resolvedFriend);
        const message = await this.xmpp.sendMessage(`${resolvedFriend.id}@${Endpoints_1.default.EPIC_PROD_ENV}`, content);
        if (!message)
            throw new SendMessageError_1.default('Message timeout exceeded', 'FRIEND', resolvedFriend);
        return new SentFriendMessage_1.default(this, {
            author: this.user, content, id: message.id, sentAt: new Date(),
        });
    }
    /* -------------------------------------------------------------------------- */
    /*                                   PARTIES                                  */
    /* -------------------------------------------------------------------------- */
    /**
     * Sends a party invitation to a friend
     * @param friend The friend that will receive the invitation
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {PartyAlreadyJoinedError} The user is already a member of this party
     * @throws {PartyMaxSizeReachedError} The party reached its max size
     * @throws {EpicgamesAPIError}
     */
    async invite(friend) {
        if (!this.party)
            throw new PartyNotFoundError_1.default();
        return this.party.invite(friend);
    }
    /**
     * Joins a party by its id
     * @param id The party id
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched
     * @throws {PartyMaxSizeReachedError} The party has reached its max size
     * @throws {EpicgamesAPIError}
     */
    async joinParty(id) {
        var _a, _b, _c, _d;
        this.partyLock.lock();
        // eslint-disable-next-line no-undef-init
        let party = undefined;
        try {
            party = await this.getParty(id);
        }
        catch (e) {
            if (e instanceof EpicgamesAPIError_1.default) {
                if (e.code === 'errors.com.epicgames.social.party.party_not_found')
                    throw new PartyNotFoundError_1.default();
                if (e.code === 'errors.com.epicgames.social.party.party_query_forbidden')
                    throw new PartyPermissionError_1.default();
                if (e.code === 'errors.com.epicgames.social.party.party_is_full')
                    throw new PartyMaxSizeReachedError_1.default();
                throw e;
            }
            else {
                throw e;
            }
        }
        if (this.party)
            await this.party.leave(false);
        const joinParty = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.BR_PARTY}/parties/${party.id}/members/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/join`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {
            connection: {
                id: this.xmpp.JID,
                meta: {
                    'urn:epic:conn:platform_s': this.config.platform,
                    'urn:epic:conn:type_s': 'game',
                },
                yield_leadership: false,
            },
            meta: {
                'urn:epic:member:dn_s': (_b = this.user) === null || _b === void 0 ? void 0 : _b.displayName,
                'urn:epic:member:joinrequestusers_j': JSON.stringify({
                    users: [
                        {
                            id: (_c = this.user) === null || _c === void 0 ? void 0 : _c.id,
                            dn: (_d = this.user) === null || _d === void 0 ? void 0 : _d.displayName,
                            plat: this.config.platform,
                            data: JSON.stringify({
                                CrossplayPreference: '1',
                                SubGame_u: '1',
                            }),
                        },
                    ],
                }),
            },
        });
        if (joinParty.error) {
            this.partyLock.unlock();
            await this.initParty(true, false);
            if (joinParty.error.code === 'errors.com.epicgames.social.party.user_has_party') {
                throw joinParty.error;
            }
            else
                throw joinParty.error;
        }
        this.party = new ClientParty_1.default(this, party.toObject());
        await this.party.chat.join();
        this.partyLock.unlock();
    }
    /**
     * Creates a new party
     * @param config The party config
     * @throws {EpicgamesAPIError}
     */
    async createParty(config) {
        var _a, _b;
        if (this.party)
            await this.party.leave();
        this.partyLock.lock();
        const partyConfig = { ...this.config.partyConfig, ...config };
        const party = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.BR_PARTY}/parties`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {
            config: {
                join_confirmation: partyConfig.joinConfirmation,
                joinability: partyConfig.joinability,
                max_size: partyConfig.maxSize,
            },
            join_info: {
                connection: {
                    id: this.xmpp.JID,
                    meta: {
                        'urn:epic:conn:platform_s': this.config.platform,
                        'urn:epic:conn:type_s': 'game',
                    },
                    yield_leadership: false,
                },
                meta: {
                    'urn:epic:member:dn_s': (_a = this.user) === null || _a === void 0 ? void 0 : _a.displayName,
                },
            },
            meta: {
                'urn:epic:cfg:party-type-id_s': 'default',
                'urn:epic:cfg:build-id_s': '1:3:',
                'urn:epic:cfg:join-request-action_s': 'Manual',
                'urn:epic:cfg:chat-enabled_b': ((_b = partyConfig.chatEnabled) === null || _b === void 0 ? void 0 : _b.toString()) || 'true',
                'urn:epic:cfg:can-join_b': 'true',
            },
        });
        if (party.error) {
            this.partyLock.unlock();
            if (party.error.code === 'errors.com.epicgames.social.party.user_has_party') {
                await this.leaveParty(false);
                return this.createParty(config);
            }
            throw party.error;
        }
        this.party = new ClientParty_1.default(this, party.response);
        const newPrivacy = await this.party.setPrivacy(partyConfig.privacy || Enums_1.default.PartyPrivacy.PUBLIC, false);
        await this.party.sendPatch({
            ...newPrivacy.updated,
            ...Object.keys(this.party.meta.schema).filter((k) => !k.startsWith('urn:'))
                // eslint-disable-next-line no-param-reassign
                .reduce((obj, key) => { var _a; obj[key] = (_a = this.party) === null || _a === void 0 ? void 0 : _a.meta.schema[key]; return obj; }, {}),
        }, newPrivacy.deleted);
        this.partyLock.unlock();
        await this.party.chat.join();
        return undefined;
    }
    /**
     * Leaves the client's current party
     * @param createNew Whether a new party should be created
     * @throws {EpicgamesAPIError}
     */
    async leaveParty(createNew = true) {
        var _a, _b;
        if (!this.party)
            return;
        this.partyLock.lock();
        if (this.party.chat.isConnected)
            await this.party.chat.leave();
        const partyLeave = await this.http.sendEpicgamesRequest(true, 'DELETE', `${Endpoints_1.default.BR_PARTY}/parties/${this.party.id}/members/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}`, 'fortnite');
        if (partyLeave.error && ((_b = partyLeave.error) === null || _b === void 0 ? void 0 : _b.code) !== 'errors.com.epicgames.social.party.party_not_found') {
            this.partyLock.unlock();
            throw partyLeave.error;
        }
        this.party = undefined;
        this.partyLock.unlock();
        if (createNew)
            await this.createParty();
    }
    /**
     * Sends a party join request to a friend.
     * When the friend confirms this, a party invite will be sent to the client
     * @param friend The friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {PartyNotFoundError} The friend is not in a party
     * @throws {EpicgamesAPIError}
     */
    async sendRequestToJoin(friend) {
        var _a;
        const resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const intention = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.BR_PARTY}/members/${resolvedFriend.id}/intentions/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {
            'urn:epic:invite:platformdata_s': '',
        });
        if (intention.error) {
            if (intention.error.code === 'errors.com.epicgames.social.party.user_has_no_party')
                throw new PartyNotFoundError_1.default();
            throw intention.error;
        }
        return new SentPartyJoinRequest_1.default(this, this.user, resolvedFriend, intention.response);
    }
    /**
     * Fetches the client's party
     * @throws {EpicgamesAPIError}
     */
    async getClientParty() {
        var _a, _b;
        const party = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_PARTY}/user/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}`, 'fortnite');
        if (party.error)
            throw party.error;
        if (!((_b = party.response) === null || _b === void 0 ? void 0 : _b.current[0]))
            return undefined;
        return new ClientParty_1.default(this, party.response.current[0]);
    }
    /**
     * Fetches a party by its id
     * @param id The party's id
     * @throws {EpicgamesAPIError}
     */
    async getParty(id) {
        const party = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_PARTY}/parties/${id}`, 'fortnite');
        if (party.error)
            throw party.error;
        const constuctedParty = new Party_1.default(this, party.response);
        await constuctedParty.updateMemberBasicInfo();
        return constuctedParty;
    }
    /* -------------------------------------------------------------------------- */
    /*                                  FORTNITE                                  */
    /* -------------------------------------------------------------------------- */
    /**
     * Fetches the current Fortnite server status (lightswitch)
     * @throws {EpicgamesAPIError}
     */
    async getFortniteServerStatus() {
        const fortniteServerStatus = await this.http.sendEpicgamesRequest(true, 'GET', Endpoints_1.default.BR_SERVER_STATUS, 'fortnite');
        if (fortniteServerStatus.error)
            throw fortniteServerStatus.error;
        return fortniteServerStatus.response[0];
    }
    /**
     * Fetches the current epicgames server status (https://status.epicgames.com/)
     * @throws {AxiosError}
     */
    async getEpicgamesServerStatus() {
        const epicgamesServerStatus = await this.http.send('GET', Endpoints_1.default.SERVER_STATUS_SUMMARY);
        if (epicgamesServerStatus.error)
            throw epicgamesServerStatus.error;
        if (!epicgamesServerStatus.response)
            throw new Error('Request returned an empty body');
        return epicgamesServerStatus.response.data;
    }
    /**
     * Fetches the current Fortnite storefronts
     * @param language The language
     * @throws {EpicgamesAPIError}
     */
    async getStorefronts(language = 'en') {
        const store = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_STORE}?lang=${language}`, 'fortnite');
        if (store.error)
            throw store.error;
        return store.response.storefronts;
    }
    /**
     * Downloads a blurl stream (eg a radio station stream or a news video)
     * @param id The stream ID
     * @throws {AxiosError}
     */
    async downloadBlurlStream(id) {
        var _a;
        const blurlFile = await this.http.send('GET', `${Endpoints_1.default.BR_STREAM}/${id}/master.blurl`, undefined, undefined, undefined, 'arraybuffer');
        if (blurlFile.error)
            throw blurlFile.error;
        const streamData = await (0, Util_1.parseBlurlStream)((_a = blurlFile.response) === null || _a === void 0 ? void 0 : _a.data);
        const streamMetaData = {
            subtitles: streamData.subtitles ? JSON.parse(streamData.subtitles) : {},
            ucp: streamData.ucp,
            audioonly: !!streamData.audioonly,
            aspectratio: streamData.aspectratio,
            partysync: !!streamData.partysync,
            lrcs: streamData.lrcs ? JSON.parse(streamData.lrcs) : {},
            duration: streamData.duration,
        };
        const languageStreams = streamData.playlists.filter((p) => p.type === 'master').map((s) => {
            var _a, _b;
            let baseURL = (_a = s.url.match(/.+\//)) === null || _a === void 0 ? void 0 : _a[0];
            if (baseURL && !baseURL.endsWith('/'))
                baseURL += '/';
            const data = (0, Util_1.parseM3U8File)(s.data);
            let variants = data.streams.map((ss) => {
                var _a, _b;
                return ({
                    data: {
                        codecs: ((_a = ss.data.CODECS) === null || _a === void 0 ? void 0 : _a.split(',')) || [],
                        bandwidth: parseInt(ss.data.BANDWIDTH, 10),
                        resolution: ss.data.RESOLUTION,
                    },
                    type: ss.data.AUDIO ? 'video' : 'audio',
                    url: `${baseURL || ''}${ss.url}`,
                    stream: (_b = streamData.playlists
                        .find((p) => p.type === 'variant' && p.rel_url === ss.url)) === null || _b === void 0 ? void 0 : _b.data.split(/\n/).map((l) => (!l.startsWith('#') && l.length > 0 ? `${baseURL || ''}${l}` : l)).join('\n').replace(/init_/g, `${baseURL || ''}init_`),
                });
            });
            if (!streamMetaData.audioonly) {
                const audioStreamUrl = (_b = variants.find((v) => v.type === 'audio')) === null || _b === void 0 ? void 0 : _b.url;
                if (audioStreamUrl) {
                    variants = variants.map((v) => ({
                        ...v,
                        stream: Buffer.from(v.type !== 'video' ? v.stream : v.stream.replace('#EXTINF:', '#EXT-X-STREAM-INF:AUDIO="group_audio"\n'
                            + `#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="group_audio",NAME="audio",DEFAULT=YES,URI="${audioStreamUrl}"\n#EXTINF:`), 'utf8'),
                    }));
                }
            }
            return {
                language: s.language,
                url: s.url,
                variants,
            };
        });
        return {
            languages: languageStreams,
            data: streamMetaData,
        };
    }
    /**
     * Fetches the avatar for one or more users
     * @param user The id(s) or display name(s) of the user(s)
     * @throws {EpicgamesAPIError}
     */
    async getUserAvatar(user) {
        const users = await this.getProfile(Array.isArray(user) ? user : [user]);
        const userChunks = users.reduce((resArr, u, i) => {
            const chunkIndex = Math.floor(i / 100);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(u);
            return resArr;
        }, []);
        const avatars = await Promise.all(userChunks
            .map((uc) => this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_AVATAR}/fortnite/ids?accountIds=${uc.map((u) => u.id).join(',')}`, 'fortnite')));
        return avatars.map((a) => {
            if (a.error && a.error.code !== 'errors.com.epicgames.account.account_not_found')
                throw a.error;
            return a.response.map((ar) => new Avatar_1.default(this, ar, users.find((u) => u.id === ar.accountId)));
        }).flat(1);
    }
    /**
     * Fetches the global profile for one or more users
     * @param user The id(s) or display name(s) of the user(s)
     * @throws {EpicgamesAPIError}
     */
    async getGlobalProfile(user) {
        const users = await this.getProfile(Array.isArray(user) ? user : [user]);
        const userChunks = users.reduce((resArr, u, i) => {
            const chunkIndex = Math.floor(i / 100);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(u);
            return resArr;
        }, []);
        const globalProfiles = await Promise.all(userChunks
            .map((uc) => this.http.sendEpicgamesRequest(true, 'PUT', `${Endpoints_1.default.ACCOUNT_GLOBAL_PROFILE}`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {
            namespace: 'Fortnite',
            accountIds: uc.map((u) => u.id),
        })));
        return globalProfiles.map((a) => {
            if (a.error)
                throw a.error;
            return a.response.profiles.map((ar) => new GlobalProfile_1.default(this, ar, users.find((u) => u.id === ar.accountId)));
        }).flat(1);
    }
    /**
     * Fetches battle royale v2 stats for one or multiple players
     * @param user The id(s) or display name(s) of the user(s)
     * @param startTime The timestamp to start fetching stats from, can be null/undefined for lifetime
     * @param endTime The timestamp to stop fetching stats from, can be undefined for lifetime
     * @param stats An array of stats keys. Required if you want to get the stats of multiple users at once (If not, ignore this)
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {StatsPrivacyError} The user set their stats to private
     * @throws {TypeError} You must provide an array of stats keys for multiple user lookup
     * @throws {EpicgamesAPIError}
     */
    async getBRStats(user, startTime, endTime, stats = []) {
        var _a;
        const params = [];
        if (startTime)
            params.push(`startTime=${startTime}`);
        if (endTime)
            params.push(`endTime=${endTime}`);
        const query = params[0] ? `?${params.join('&')}` : '';
        if (typeof user === 'string') {
            const userID = await this.resolveUserId(user);
            if (!userID)
                throw new UserNotFoundError_1.default(user);
            const statsResponse = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_STATS_V2}/account/${userID}${query}`, 'fortnite');
            if (!statsResponse.error && !statsResponse.response)
                throw new StatsPrivacyError_1.default(user);
            if (statsResponse.error)
                throw statsResponse.error;
            return {
                ...statsResponse.response,
                query: user,
            };
        }
        if (!stats[0])
            throw new TypeError('You need to provide an array of stats keys to fetch multiple user\'s stats');
        const ids = await this.resolveUserIds(user);
        const idChunks = ids.reduce((resArr, id, i) => {
            const chunkIndex = Math.floor(i / 51);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(id);
            return resArr;
        }, []);
        const statsResponses = await Promise.all(idChunks.map((c) => this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.BR_STATS_V2}/query${query}`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {
            appId: 'fortnite',
            owners: c.map((o) => o.id),
            stats,
        })));
        if (statsResponses.some((r) => r.error))
            throw (_a = statsResponses.find((r) => r.error)) === null || _a === void 0 ? void 0 : _a.error;
        return statsResponses.map((r) => r.response).flat(1).map((r) => {
            var _a;
            return ({
                ...r,
                query: (_a = ids.find((id) => id.id === r.accountId)) === null || _a === void 0 ? void 0 : _a.query,
            });
        });
    }
    /**
     * Fetches the current news for a specific gamemode
     * @param mode The gamemode to fetch the news for
     * @param language The language of the news
     * @throws {EpicgamesAPIError}
     */
    async getNews(mode = 'battleroyale', language = 'en') {
        var _a, _b;
        const news = await this.http.sendEpicgamesRequest(false, 'GET', `${Endpoints_1.default.BR_NEWS}/${mode}news${mode === 'savetheworld' ? '' : 'v2'}?lang=${language}`);
        if (news.error)
            throw news.error;
        const { messages, motds, platform_motds: platformMotds } = news.response.news;
        if (mode === 'savetheworld')
            return messages;
        const oldNewsMessages = [...motds, ...(platformMotds || []).filter((m) => m.platform === 'windows').map((m) => m.message)];
        if (mode === 'creative')
            return oldNewsMessages;
        const newNews = await this.http.sendEpicgamesRequest(true, 'POST', Endpoints_1.default.BR_NEWS_MOTD, 'fortnite', undefined, {
            platform: 'Windows',
            language: 'en',
            country: 'US',
            serverRegion: 'NA',
            subscription: false,
            battlepass: false,
            battlepassLevel: 1,
        });
        if (newNews.error)
            throw newNews.error;
        const newsMessages = ((_b = (_a = newNews.response) === null || _a === void 0 ? void 0 : _a.contentItems) === null || _b === void 0 ? void 0 : _b.map((i, y) => {
            var _a, _b, _c, _d;
            return ({
                _type: i.contentSchemaName,
                body: i.contentFields.body,
                entryType: i.contentFields.entryType,
                hidden: i.contentFields.hidden,
                id: i.contentId,
                image: (_b = (_a = i.contentFields.image) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.url,
                offerAction: i.contentFields.offerAction,
                sortingPriority: 1000 - y,
                spotlight: i.contentFields.spotlight,
                tabTitleOverride: i.contentFields.tabTitleOverride,
                tileImage: (_d = (_c = i.contentFields.tileImage) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.url,
                title: i.contentFields.title,
                videoAutoplay: i.contentFields.videoAutoplay,
                videoFullscreen: i.contentFields.videoFullscreen,
                videoLoop: i.contentFields.videoLoop,
                videoMute: i.contentFields.videoMute,
                videoStreamingEnabled: i.contentFields.videoStreamingEnabled,
                buttonTextOverride: i.contentFields.buttonTextOverride,
                offerId: i.contentFields.offerId,
                playlistId: i.contentFields.playlistId,
                videoUID: i.contentFields.videoUID,
                videoVideoString: i.contentFields.videoVideoString,
            });
        })) || [];
        oldNewsMessages.forEach((omsg) => {
            if (!newsMessages.some((msg) => msg.title === omsg.title && msg.body === omsg.body)) {
                newsMessages.push(omsg);
            }
        });
        return newsMessages;
    }
    /**
     * Fetches data for a Support-A-Creator code
     * @param code The Support-A-Creator code (slug)
     * @throws {CreatorCodeNotFoundError} The Support-A-Creator code wasnt found
     * @throws {EpicgamesAPIError}
     */
    async getCreatorCode(code) {
        const codeResponse = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_SAC}/${encodeURIComponent(code)}`, 'fortniteClientCredentials');
        if (codeResponse.error) {
            if (codeResponse.error.code === 'errors.com.epicgames.ecommerce.affiliate.not_found')
                throw new CreatorCodeNotFoundError_1.default(code);
            throw codeResponse.error;
        }
        const owner = await this.getProfile(codeResponse.response.id);
        return new CreatorCode_1.default(this, { ...codeResponse.response, owner });
    }
    /**
     * Fetches the current Fortnite battle royale radio stations
     * @throws {EpicgamesAPIError}
     */
    async getRadioStations() {
        const fortniteContent = await this.http.sendEpicgamesRequest(false, 'GET', Endpoints_1.default.BR_NEWS);
        if (fortniteContent.error)
            throw fortniteContent.error;
        const radioStations = fortniteContent.response.radioStations.radioStationList.stations;
        return radioStations.map((s) => new RadioStation_1.default(this, s));
    }
    /**
     * Fetches the current battle royale event flags
     * @param language The language
     * @throws {EpicgamesAPIError}
     */
    async getBREventFlags(language = 'en') {
        const eventFlags = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_EVENT_FLAGS}?lang=${language}`, 'fortnite');
        if (eventFlags.error)
            throw eventFlags.error;
        return eventFlags.response;
    }
    /**
     * Fetches the battle royale account level for one or multiple users
     * @param user The id(s) and/or display name(s) of the user(s) to fetch the account level for
     * @param seasonNumber The season number (eg. 16, 17, 18)
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {StatsPrivacyError} The user set their stats to private
     * @throws {EpicgamesAPIError}
     */
    async getBRAccountLevel(user, seasonNumber) {
        if (seasonNumber < 11)
            throw new RangeError('The season number must be at least 11');
        const users = Array.isArray(user) ? user : [user];
        const accountLevels = await this.getBRStats(users, undefined, undefined, [`s${seasonNumber}_social_bp_level`]);
        return accountLevels.map((al) => ({
            query: al.query,
            level: al.stats[`s${seasonNumber}_social_bp_level`] || 0,
        }));
    }
    /**
     * Fetches the storefront keychain
     * @throws {EpicgamesAPIError}
     */
    async getStorefrontKeychain() {
        const keychain = await this.http.sendEpicgamesRequest(true, 'GET', Endpoints_1.default.BR_STORE_KEYCHAIN, 'fortnite');
        if (keychain.error)
            throw keychain.error;
        return keychain.response;
    }
    /* -------------------------------------------------------------------------- */
    /*                     FORTNITE BATTLE ROYALE TOURNAMENTS                     */
    /* -------------------------------------------------------------------------- */
    /**
     * Fetches the event tokens for an account.
     * This can be used to check if a user is eligible to play a certain tournament window
     * or to check a user's arena division in any season
     * @param user The id(s) or display name(s) of the user(s)
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async getEventTokens(user) {
        const users = typeof user === 'string' ? [user] : user;
        const resolvedUsers = await this.getProfile(users);
        const userChunks = resolvedUsers.map((u) => u.id).reduce((resArr, usr, i) => {
            const chunkIndex = Math.floor(i / 16);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(usr);
            return resArr;
        }, []);
        const statsResponses = await Promise.all(userChunks.map((c) => this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_TOURNAMENT_TOKENS}?teamAccountIds=${c.join(',')}`, 'fortnite')));
        return statsResponses.map((r) => r.response.accounts).flat(1).map((r) => ({
            user: resolvedUsers.find((u) => u.id === r.accountId),
            tokens: r.tokens,
        }));
    }
    /**
     * Fetches the current and past battle royale tournaments
     * @param region The region
     * @param platform The platform
     * @throws {EpicgamesAPIError}
     */
    async getTournaments(region = 'EU', platform = 'Windows') {
        var _a, _b;
        const [tournaments, tournamentsInfo] = await Promise.all([
            this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_TOURNAMENTS_DOWNLOAD}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}?region=${region}&platform=${platform}&teamAccountIds=${(_b = this.user) === null || _b === void 0 ? void 0 : _b.id}`, 'fortnite'),
            this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_NEWS}/tournamentinformation`, 'fortnite'),
        ]);
        if (tournaments.error)
            throw tournaments.error;
        if (tournamentsInfo.error)
            throw tournamentsInfo.error;
        const constuctedTournaments = [];
        tournaments.response.events.forEach((t) => {
            var _a, _b, _c, _d, _e;
            let tournamentDisplayData = (_c = (_b = (_a = tournamentsInfo.response) === null || _a === void 0 ? void 0 : _a.tournament_info) === null || _b === void 0 ? void 0 : _b.tournaments) === null || _c === void 0 ? void 0 : _c.find((td) => td.tournament_display_id === t.displayDataId);
            if (!tournamentDisplayData) {
                tournamentDisplayData = (_e = (_d = tournamentsInfo.response) === null || _d === void 0 ? void 0 : _d[t.displayDataId.split('_').map((s, i) => (i > 0 ? `${s.charAt(0).toUpperCase()}${s.slice(1)}` : s)).join('')]) === null || _e === void 0 ? void 0 : _e.tournament_info;
            }
            if (!tournamentDisplayData)
                return;
            const templates = [];
            t.eventWindows.forEach((w) => {
                const template = tournaments.response.templates.find((tt) => tt.eventTemplateId === w.eventTemplateId);
                if (template)
                    templates.push({ windowId: w.eventWindowId, templateData: template });
            });
            constuctedTournaments.push(new Tournament_1.default(this, t, tournamentDisplayData, templates));
        });
        return constuctedTournaments;
    }
    /**
     * Fetches the results for a tournament window
     * @param eventId The tournament's ID
     * @param eventWindowId The tournament window's ID
     * @param showLiveSessions Whether to show live sessions
     * @param page The results page index
     * @throws {EpicgamesAPIError}
     */
    async getTournamentWindowResults(eventId, eventWindowId, showLiveSessions = false, page = 0) {
        var _a;
        const window = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_TOURNAMENT_WINDOW}/${eventId}/${eventWindowId}/`
            + `${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}?page=${page}&rank=0&teamAccountIds=&appId=Fortnite&showLiveSessions=${showLiveSessions}`, 'fortnite');
        if (window.error)
            throw window.error;
        return window.response;
    }
    /**
     * Downloads a tournament replay by its session ID.
     * This method returns a regular Fortnite replay file, can be parsed using https://github.com/ThisNils/node-replay-reader
     * @param sessionId The session ID
     * @param options Replay download and build options
     * @throws {MatchNotFoundError} The match wasn't found
     * @throws {EpicgamesAPIError}
     * @throws {AxiosError}
     */
    async downloadTournamentReplay(sessionId, options) {
        var _a;
        const downloadConfig = {
            dataTypes: ['EVENT', 'DATACHUNK'],
            addStatsPlaceholder: false,
            ...options,
        };
        const replayMetadataResponse = await this.downloadReplayCDNFile(`${Endpoints_1.default.BR_REPLAY_METADATA}%2F${sessionId}.json`, 'json');
        if (replayMetadataResponse.error) {
            if (!(replayMetadataResponse.error instanceof EpicgamesAPIError_1.default)
                && ((_a = replayMetadataResponse.error.response) === null || _a === void 0 ? void 0 : _a.data.includes('<Message>The specified key does not exist.</Message>'))) {
                throw new MatchNotFoundError_1.default(sessionId);
            }
            throw replayMetadataResponse.error;
        }
        const replayHeaderResponse = await this.downloadReplayCDNFile(`${Endpoints_1.default.BR_REPLAY}%2F${sessionId}%2Fheader.bin`, 'arraybuffer');
        if (replayHeaderResponse.error)
            throw replayHeaderResponse.error;
        const replayData = replayMetadataResponse.response;
        replayData.Header = replayHeaderResponse.response;
        const downloadKeys = new Set(['Events', 'DataChunks', 'Checkpoints']);
        if (!downloadConfig.dataTypes.includes('EVENT')) {
            downloadKeys.delete('Events');
            delete replayData.Events;
        }
        if (!downloadConfig.dataTypes.includes('DATACHUNK')) {
            downloadKeys.delete('DataChunks');
            delete replayData.DataChunks;
        }
        if (!downloadConfig.dataTypes.includes('CHECKPOINT')) {
            downloadKeys.delete('Checkpoints');
            delete replayData.Checkpoints;
        }
        const promises = [];
        for (const downloadKey of downloadKeys.values()) {
            const chunks = replayData[downloadKey];
            for (const chunk of chunks) {
                promises.push(this.downloadReplayCDNFile(`${Endpoints_1.default.BR_REPLAY}%2F${sessionId}%2F${chunk.Id}.bin`, 'arraybuffer').then((resp) => {
                    if (resp.error)
                        throw resp.error;
                    chunks.find((d) => d.Id === chunk.Id).data = resp.response;
                }));
            }
        }
        await Promise.all(promises);
        return (0, Util_1.buildReplay)(replayData, downloadConfig.addStatsPlaceholder);
    }
    /**
     * Fetches a tournament session's metadata
     * @param sessionId The session ID
     * @throws {MatchNotFoundError} The match wasn't found
     * @throws {EpicgamesAPIError}
     * @throws {AxiosError}
     */
    async getTournamentSessionMetadata(sessionId) {
        var _a;
        const replayMetadataResponse = await this.downloadReplayCDNFile(`${Endpoints_1.default.BR_REPLAY_METADATA}%2F${sessionId}.json`, 'json');
        if (replayMetadataResponse.error) {
            if (!(replayMetadataResponse.error instanceof EpicgamesAPIError_1.default)
                && ((_a = replayMetadataResponse.error.response) === null || _a === void 0 ? void 0 : _a.data.includes('<Message>The specified key does not exist.</Message>'))) {
                throw new MatchNotFoundError_1.default(sessionId);
            }
            throw replayMetadataResponse.error;
        }
        return {
            changelist: replayMetadataResponse.response.Changelist,
            checkpoints: replayMetadataResponse.response.Checkpoints,
            dataChunks: replayMetadataResponse.response.DataChunks,
            desiredDelayInSeconds: replayMetadataResponse.response.DesiredDelayInSeconds,
            events: replayMetadataResponse.response.Events,
            friendlyName: replayMetadataResponse.response.FriendlyName,
            lengthInMS: replayMetadataResponse.response.LengthInMS,
            networkVersion: replayMetadataResponse.response.NetworkVersion,
            replayName: replayMetadataResponse.response.ReplayName,
            timestamp: new Date(replayMetadataResponse.response.Timestamp),
            isCompressed: replayMetadataResponse.response.bCompressed,
            isLive: replayMetadataResponse.response.bIsLive,
        };
    }
    /**
     * Downloads a file from the CDN (used for replays)
     * @param url The URL of the file to download
     * @param responseType The response type
     */
    async downloadReplayCDNFile(url, responseType) {
        const fileLocationInfo = await this.http.sendEpicgamesRequest(true, 'GET', url, 'fortnite');
        if (fileLocationInfo.error)
            return fileLocationInfo;
        const file = await this.http.send('GET', Object.values(fileLocationInfo.response.files)[0].readLink, undefined, undefined, undefined, responseType);
        if (file.response)
            return { response: file.response.data };
        return file;
    }
    /* -------------------------------------------------------------------------- */
    /*                              FORTNITE CREATIVE                             */
    /* -------------------------------------------------------------------------- */
    /**
     * Fetches a creative island by its code
     * @param code The island code
     * @throws {CreativeIslandNotFoundError} A creative island with the provided code does not exist
     * @throws {EpicgamesAPIError}
     */
    async getCreativeIsland(code) {
        const islandInfo = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.CREATIVE_ISLAND_LOOKUP}/${code}`, 'fortnite');
        if (islandInfo.error) {
            if (islandInfo.error.code === 'errors.com.epicgames.links.no_active_version')
                throw new CreativeIslandNotFoundError_1.default(code);
            throw islandInfo.error;
        }
        return islandInfo.response;
    }
    /**
     * Fetches the creative discovery surface
     * @param gameVersion The current game version (MAJOR.MINOR)
     * @throws {EpicgamesAPIError}
     */
    async getCreativeDiscoveryPanels(gameVersion = '18.30') {
        var _a, _b;
        const creativeDiscovery = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.CREATIVE_DISCOVERY}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}`, 'fortnite', {
            'Content-Type': 'application/json',
            'User-Agent': `Fortnite/++Fortnite+Release-${gameVersion}-CL-00000000 Windows/10`,
        }, {
            surfaceName: 'CreativeDiscoverySurface_Frontend',
            partyMemberIds: [(_b = this.user) === null || _b === void 0 ? void 0 : _b.id],
        });
        if (creativeDiscovery.error) {
            throw creativeDiscovery.error;
        }
        return creativeDiscovery.response.Panels;
    }
}
exports.default = Client;
//# sourceMappingURL=Client.js.map