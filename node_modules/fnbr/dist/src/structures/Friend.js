"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const User_1 = (0, tslib_1.__importDefault)(require("./User"));
/**
 * Represents a friend
 */
class Friend extends User_1.default {
    /**
     * @param client The main client
     * @param data The friend data
     */
    constructor(client, data) {
        super(client, data);
        this.connections = data.connections || {};
        this.mutualFriends = data.mutual;
        this.favorite = data.favorite;
        this.createdAt = new Date(data.created);
        this.note = data.note;
        this.alias = data.alias;
        this.presence = undefined;
        this.party = undefined;
        this.lastAvailableTimestamp = undefined;
    }
    /**
     * Whether a user is online or not
     * @readonly
     */
    get isOnline() {
        return !!this.lastAvailableTimestamp && Date.now() - this.lastAvailableTimestamp < 300000;
    }
    /**
     * Whether the client can join this friend's party or not
     * May be slighly inaccurate as it uses the last received presence
     * @readonly
     */
    get isJoinable() {
        var _a;
        if (!this.isOnline)
            return false;
        return !!((_a = this.presence) === null || _a === void 0 ? void 0 : _a.isJoinable);
    }
    /**
     * Removes this friend
     * @throws {FriendNotFoundError} The user is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async remove() {
        return this.client.removeFriend(this.id);
    }
    /**
     * Sends a message to this friend
     * @param content The message that will be sent
     * @throws {FriendNotFoundError} The user is not friends with the client
     */
    sendMessage(content) {
        return this.client.sendFriendMessage(this.id, content);
    }
    /**
     * Sends a party join request to this friend.
     * When the friend confirms this, a party invite will be sent to the client
     * @throws {EpicgamesAPIError}
     */
    async sendJoinRequest() {
        return this.client.sendRequestToJoin(this.id);
    }
    /**
     * Sends a party invitation to this friend
     * @throws {FriendNotFoundError} The user is not friends with the client
     * @throws {PartyAlreadyJoinedError} The user is already a member of this party
     * @throws {PartyMaxSizeReachedError} The party reached its max size
     * @throws {EpicgamesAPIError}
     */
    async invite() {
        return this.client.invite(this.id);
    }
    /**
     * Fetches the friends the client shares with this friend
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async getMutualFriends() {
        return this.client.getMutualFriends(this.id);
    }
    /**
     * Checks whether this friend owns a specific offer
     * @param friend The id or display name of the friend
     * @param offerId The offer id
     * @throws {OfferNotFoundError} The offer does not exist or is not in the current storefront catalog
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async checkOfferOwnership(offerId) {
        return this.client.checkFriendOfferOwnership(this.id, offerId);
    }
}
exports.default = Friend;
//# sourceMappingURL=Friend.js.map